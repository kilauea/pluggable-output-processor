#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

import os
import sys
import portage.output

try:
    import portage.output
    log = portage.output.EOutput()

except ImportError:
    class FakeLogger(object):
        def einfo(self, msg):
            print(msg)
        def eerror(self, msg):
            print(msg, file=sys.stderr)
        def ewarn(self, msg):
            print(msg)

    log = FakeLogger()


class Application(object):

    def run(self):
        self.abspath = os.path.abspath(sys.argv[0])
        self.basename = os.path.basename(self.abspath)
        self.dirname = os.path.dirname(self.abspath)

        # Look for a plugin to postprocess an output of the given command
        try:
            self.pp_mod = __import__(
                'outproc.pp.{}'.format(self.basename)
              , globals()
              , locals()
              , ['outproc.pp']
              )
        except:
            log.eerror('Failed to import module {}'.format(self.basename))
            return -1

        if hasattr(self.pp_mod, 'foo'):
            self.pp_mod.foo()
        else:
            log.eerror('Module {} do not provide `foo()`'.format(self.basename))
            return -1

        # Try to find a wrapped executable
        for path in os.environ['PATH'].split(os.pathsep):
            if path != self.dirname and os.path.isfile(os.path.join(path, self.basename)):
                break

        #

if __name__ == "__main__":
    try:
        a = Application()
        a.run()
    except KeyboardInterrupt:
        sys.exit(1)
    except RuntimeError as ex:
        log.eerror('Error: {}'.format(ex))
        sys.exit(1)
    sys.exit(0)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Pluggable Output Processor (main module)
#
# Copyright (c) 2013 Alex Turbov <i.zaufi@gmail.com>
#
# Pluggable Output Processor is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pluggable Output Processor is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.


import fcntl
import os
import sys
import portage.output
import select
import subprocess

# Project specific imports
import outproc


try:
    import portage.output
    log = portage.output.EOutput()
except ImportError:
    class FakeLogger(object):
        def einfo(self, msg):
            print(msg)
        def eerror(self, msg):
            print(msg, file=sys.stderr)
        def ewarn(self, msg):
            print(msg)

    log = FakeLogger()


class Application(object):

    def _get_capture_flags(self, string):
        ''' Return tuple of special values for subprocess.Popen ctor
            based on configuration key `capture` which has the following format:

                capture = STDOUT
                capture = STDERR
                or
                capture = STDOUT,STDERR
        '''
        stdin = None
        stdout = None
        stderr = None
        for item in [i.strip() for i in string.split(',')]:
            if item == 'STDOUT':
                stdout = subprocess.PIPE
            elif item == 'STDERR':
                stderr = subprocess.PIPE
            elif item == 'STDIN':
                stderr = sys.stdin
            else:
                raise RuntimeError('Invalid `capture` parameter')
        if stdout is None and stderr is None:
            raise RuntimeError('Invalid `capture` parameter')
        return (stdin, stdout, stderr)


    def _make_async(self, fd):
        '''Switch given file descriptor to asynchronous mode'''
        fcntl.fcntl(fd, fcntl.F_SETFL, fcntl.fcntl(fd, fcntl.F_GETFL) | os.O_NONBLOCK)


    def run(self):
        self.abspath = os.path.abspath(sys.argv[0])
        self.basename = os.path.basename(self.abspath)
        self.dirname = os.path.dirname(self.abspath)

        # Try to find a wrapped executable
        self.binary = None
        for path in os.environ['PATH'].split(os.pathsep):
            binary = os.path.join(path, self.basename)
            if path != self.dirname and os.path.isfile(binary):
                self.binary = binary
                break
        if self.binary is None:
            log.eerror('Command not found: {}'.format(self.basename))
            return 1

        # Look for a plugin to postprocess an output of the given command
        try:
            self.pp_mod = __import__(
                'outproc.pp.{}'.format(self.basename)
              , globals()
              , locals()
              , ['outproc.pp']
              )
        except:
            log.eerror('Failed to import module {}'.format(self.basename))
            return 1

        # Make sure the module found has a Processor class
        if not hasattr(self.pp_mod, 'Processor') or not issubclass(self.pp_mod.Processor, outproc.Processor):
            log.eerror('Module {} do not provide class `Processor`'.format(self.pp_mod.__name__))
            return 1

        # Try to load configuration for selected plugin
        config = None
        try:
            config = outproc.Config(os.path.join(outproc.SYSCONFDIR, self.basename + '.conf'))
        except Exception as e:
            log.eerror('Unable to load configuration data: {}'.format(e))
            return 1

        # Make an instance of an output processor
        processor = self.pp_mod.Processor(config)

        try:
            stdin, stdout, stderr = self._get_capture_flags(config.get_string('capture', default='STDOUT'))
            # Make a poll object
            po = select.epoll()
            fds = {}
            # Execute wrapped (and found) binary
            process = subprocess.Popen(
                [self.binary] + sys.argv[1:]
              , bufsize=1
              , stdin=stdin
              , stdout=stdout
              , stderr=stderr
              , shell=False
              )
            # Register descriptors for polling
            if stdout is not None:
                self._make_async(process.stdout)
                po.register(process.stdout, select.EPOLLIN)
                fds[process.stdout.fileno()] = process.stdout
            if stderr is not None:
                self._make_async(process.stderr)
                po.register(process.stderr, select.EPOLLIN)
                fds[process.stderr.fileno()]  = process.stderr

            # Handle output
            while True:
                # Wait for data to become available
                for fileno, event in po.poll():
                    # Check if input available
                    if event & select.EPOLLIN or event & select.EPOLLIN:
                        # Read one line
                        data = fds[fileno].readline().decode('utf-8').rstrip()
                        # Process input data
                        if fds[fileno] == process.stdout:
                            data = processor.handle_stdout(data)
                        elif fds[fileno] == process.stderr:
                            data = processor.handle_stderr(data)
                        else:
                            assert(not 'This should not happen')
                        # Print it ASAP
                        print(data)
                        sys.stdout.flush()
                    else:
                        assert(not 'Unexpected event')
                # Check is child exits
                result = process.poll()
                if result is not None:
                    return result


        except Exception as e:
            raise
            log.eerror('Failure to processing output of `{}`: {}'.format(self.basename, e))
            return 1


if __name__ == "__main__":
    try:
        a = Application()
        sys.exit(a.run())
    except KeyboardInterrupt:
        sys.exit(1)
    except RuntimeError as ex:
        log.eerror('Error: {}'.format(ex))
        sys.exit(1)
